#include <Arduino.h>
#include <Wire.h>
#include <TFT_eSPI.h>
#include <Adafruit_MCP23X17.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include "config.h"

// ========================================
// Global Objects
// ========================================
TFT_eSPI tft = TFT_eSPI();
Adafruit_MCP23X17 mcp;

// BLE objects
BLEServer* pServer = nullptr;
BLECharacteristic* pTempCharacteristic = nullptr;
BLECharacteristic* pSetpointCharacteristic = nullptr;
BLECharacteristic* pStatusCharacteristic = nullptr;
bool deviceConnected = false;

// BLE UUIDs
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define TEMP_CHAR_UUID      "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define SETPOINT_CHAR_UUID  "beb5483e-36e1-4688-b7f5-ea07361b26a9"
#define STATUS_CHAR_UUID    "beb5483e-36e1-4688-b7f5-ea07361b26aa"

// BLE Server Callbacks
class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
        deviceConnected = true;
        Serial.println("BLE Client connected");
    };

    void onDisconnect(BLEServer* pServer) {
        deviceConnected = false;
        Serial.println("BLE Client disconnected");
        // Restart advertising
        BLEDevice::startAdvertising();
        Serial.println("BLE advertising restarted");
    }
};

// Touch calibration data (calibrated for this 3.5" CYD board)
uint16_t calData[5] = {326, 3433, 551, 3091, 7};

// ========================================
// State Variables
// ========================================
float currentTemp = 0.0f;
float setpointTemp = DEFAULT_SETPOINT_F;
bool heaterOn = false;
bool sensorError = false;
bool safetyShutdown = false;

unsigned long lastTempRead = 0;
unsigned long lastDisplayUpdate = 0;
unsigned long lastTouchTime = 0;
unsigned long lastRelayChange = 0;

// Global display buffer to avoid stack allocation
static char displayBuffer[32];

// ========================================
// Function Prototypes
// ========================================
void initI2C();
void initMCP23017();
void initDisplay();
void initBluetooth();
void updateBluetooth();
void calibrateTouch();
float readMAX6675();
uint16_t readMAX6675Raw();
void bitBangSPI(uint8_t& byte1, uint8_t& byte2);
void updateThermostat();
void updateDisplay();
void handleTouch();
void setRelay(bool state);
void drawButton(int x, int y, int w, int h, const char* label, uint16_t color);
void drawUI();

// ========================================
// ========================================
// BLE Setpoint Write Callback
// ========================================
class SetpointCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic* pCharacteristic) {
        std::string value = pCharacteristic->getValue();

        Serial.println("================================");
        Serial.println("=== BLE WRITE CALLBACK FIRED ===");
        Serial.println("================================");
        
        if (value.length() > 0) {
            Serial.printf("Received value: '%s'\n", value.c_str());
            Serial.printf("Value length: %d bytes\n", value.length());
            
            // Parse the incoming value as float
            float newSetpoint = atof(value.c_str());
            Serial.printf("Parsed as float: %.1f°F\n", newSetpoint);
            Serial.printf("Current setpointTemp BEFORE: %.1f°F\n", setpointTemp);

            // Validate range
            if (newSetpoint >= MIN_SETPOINT_F && newSetpoint <= MAX_SETPOINT_F) {
                Serial.println("✓ Value is within valid range");
                
                setpointTemp = newSetpoint;
                Serial.printf("✓ setpointTemp UPDATED to: %.1f°F\n", setpointTemp);

                // Reset safety shutdown if conditions allow
                if (safetyShutdown && currentTemp < SAFETY_MAX_TEMP_F && !sensorError) {
                    safetyShutdown = false;
                    Serial.println("✓ Safety shutdown reset");
                }

                // Send notification back to confirm
                char setpointStr[16];
                snprintf(setpointStr, sizeof(setpointStr), "%.1f", setpointTemp);
                pCharacteristic->setValue(setpointStr);
                pCharacteristic->notify();
                Serial.printf("✓ BLE notification sent: %s\n", setpointStr);

                // Update display immediately
                updateDisplay();
                Serial.println("✓ Display update called");
            } else {
                Serial.println("✗ REJECTED - Value out of range!");
                Serial.printf("  Range: %.1f°F to %.1f°F\n", MIN_SETPOINT_F, MAX_SETPOINT_F);
                Serial.printf("  Received: %.1f°F\n", newSetpoint);
            }
            
            Serial.printf("Current setpointTemp AFTER: %.1f°F\n", setpointTemp);
        } else {
            Serial.println("✗ ERROR: Empty value received");
        }
        
        Serial.println("================================\n");
    }
};

// ========================================
// Setup
// ========================================
void setup() {
    Serial.begin(115200);
    delay(1000);
    Serial.println("\n\nSmart Oil Heater Controller");
    Serial.println("============================");

    // Enable backlight on GPIO27 (3.5" CYD backlight pin)
    Serial.println("Enabling backlight on GPIO27...");
    pinMode(27, OUTPUT);
    digitalWrite(27, HIGH);
    Serial.println("Backlight enabled");
    delay(500);

    // Initialize I2C
    initI2C();

    // Initialize MCP23017
    initMCP23017();

    // Initialize Display
    initDisplay();

    // Initialize Touch (built-in TFT_eSPI touch support)
    Serial.println("Initializing touchscreen...");
    tft.setTouch(calData);
    Serial.println("Touch initialized with calibration data");
    Serial.println("Note: Send 'c' via serial to run calibration");

    // Initialize Bluetooth
    initBluetooth();

    // Turn off heater initially
    setRelay(false);

    // Draw initial UI
    drawUI();

    Serial.println("Initialization complete!");
    Serial.printf("Default setpoint: %.1f°F\n", setpointTemp);
}

// ========================================
// Main Loop
// ========================================
void loop() {
    unsigned long currentMillis = millis();

    // Check for serial commands
    if (Serial.available() > 0) {
        char cmd = Serial.read();
        if (cmd == 'c' || cmd == 'C') {
            calibrateTouch();
            drawUI();  // Redraw UI after calibration
        }
    }

    // Read temperature periodically
    if (currentMillis - lastTempRead >= TEMP_READ_INTERVAL) {
        lastTempRead = currentMillis;
        currentTemp = readMAX6675();

        // Check for sensor error
        if (currentTemp >= SENSOR_ERROR_TEMP) {
            sensorError = true;
            safetyShutdown = true;
            setRelay(false);
            Serial.println("ERROR: Sensor error detected!");
        } else {
            sensorError = false;
        }

        // Check for over-temperature
        if (currentTemp > SAFETY_MAX_TEMP_F && !sensorError) {
            safetyShutdown = true;
            setRelay(false);
            Serial.printf("ERROR: Over-temperature detected! Temp: %.1f°F\n", currentTemp);
        }

        // Debug: Print system state
        Serial.println("--- System State ---");
        Serial.printf("Current Temp: %.1f°F\n", currentTemp);
        Serial.printf("Setpoint: %.1f°F (Hysteresis ±%.1f°F)\n", setpointTemp, TEMP_HYSTERESIS_F);
        Serial.printf("Heater: %s\n", heaterOn ? "ON" : "OFF");
        Serial.printf("Safety Shutdown: %s\n", safetyShutdown ? "YES" : "NO");
        Serial.printf("Sensor Error: %s\n", sensorError ? "YES" : "NO");
        unsigned long timeSinceRelayChange = (currentMillis - lastRelayChange) / 1000;
        Serial.printf("Time since last relay change: %lu sec (min: %d sec)\n",
                     timeSinceRelayChange, RELAY_MIN_CYCLE_TIME / 1000);

        if (!heaterOn) {
            float turnOnThreshold = setpointTemp - TEMP_HYSTERESIS_F;
            Serial.printf("Heater will turn ON when temp < %.1f°F\n", turnOnThreshold);
            if (currentTemp >= turnOnThreshold) {
                Serial.printf("  -> Still %.1f°F above turn-on threshold\n",
                             currentTemp - turnOnThreshold);
            }
        } else {
            float turnOffThreshold = setpointTemp + TEMP_HYSTERESIS_F;
            Serial.printf("Heater will turn OFF when temp > %.1f°F\n", turnOffThreshold);
        }
        Serial.println("-------------------");

        // Update thermostat logic if not in safety shutdown
        if (!safetyShutdown) {
            updateThermostat();
        } else {
            Serial.println("THERMOSTAT DISABLED: Safety shutdown active!");
            Serial.println("To reset: Adjust setpoint when temp < 300°F and sensor OK");
        }
    }

    // Update display and Bluetooth periodically
    if (currentMillis - lastDisplayUpdate >= DISPLAY_UPDATE_INTERVAL) {
        lastDisplayUpdate = currentMillis;
        updateDisplay();
        updateBluetooth();
    }

    // Handle touch input
    handleTouch();

    delay(10);
}

// ========================================
// I2C Initialization
// ========================================
void initI2C() {
    Serial.println("Initializing I2C...");
    Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
    Wire.setClock(I2C_FREQUENCY);
    Serial.printf("I2C initialized on SDA=%d, SCL=%d\n", I2C_SDA_PIN, I2C_SCL_PIN);
}

// ========================================
// MCP23017 Initialization
// ========================================
void initMCP23017() {
    Serial.println("Initializing MCP23017...");

    if (!mcp.begin_I2C(MCP23017_ADDR)) {
        Serial.println("ERROR: MCP23017 not found!");
        while (1) delay(10);
    }

    // Configure pins
    mcp.pinMode(MCP_RELAY_PIN, OUTPUT);      // Relay control
    mcp.pinMode(MCP_MAX6675_SCK, OUTPUT);    // MAX6675 SCK
    mcp.pinMode(MCP_MAX6675_CS, OUTPUT);     // MAX6675 CS
    mcp.pinMode(MCP_MAX6675_SO, INPUT);      // MAX6675 SO (data)

    // Set initial states
    mcp.digitalWrite(MCP_RELAY_PIN, LOW);    // Relay off (active HIGH)
    mcp.digitalWrite(MCP_MAX6675_CS, HIGH);  // CS high (inactive)
    mcp.digitalWrite(MCP_MAX6675_SCK, LOW);  // SCK low

    Serial.println("MCP23017 initialized");
}

// ========================================
// Display Initialization
// ========================================
void initDisplay() {
    Serial.println("Initializing display...");
    tft.init();
    tft.setRotation(1);  // Landscape mode
    tft.fillScreen(COLOR_BG);
    Serial.println("Display initialized");
}

// ========================================
// Touch Calibration
// ========================================
void calibrateTouch() {
    Serial.println("\n=== TOUCH CALIBRATION ===");
    Serial.println("Touch the corners when prompted...");

    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextSize(2);
    tft.setTextDatum(MC_DATUM);
    tft.drawString("Touch Screen Calibration", 240, 100);
    tft.drawString("Follow the prompts", 240, 140);
    delay(2000);

    tft.calibrateTouch(calData, TFT_WHITE, TFT_BLACK, 15);

    Serial.println("\n=== CALIBRATION COMPLETE ===");
    Serial.printf("Calibration data: {%d, %d, %d, %d, %d}\n",
                  calData[0], calData[1], calData[2], calData[3], calData[4]);
    Serial.println("Copy these values to calData array in code for permanent calibration");
    Serial.println("=============================\n");

    tft.setTouch(calData);
    delay(1000);
}

// ========================================
// Bluetooth Initialization
// ========================================
void initBluetooth() {
    Serial.println("Initializing Bluetooth...");

    // Create BLE Device
    BLEDevice::init("Heater_Controller");

    // Create BLE Server
    pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());

    // Create BLE Service
    BLEService *pService = pServer->createService(SERVICE_UUID);

    // Create Temperature Characteristic
    pTempCharacteristic = pService->createCharacteristic(
        TEMP_CHAR_UUID,
        BLECharacteristic::PROPERTY_READ |
        BLECharacteristic::PROPERTY_NOTIFY
    );
    pTempCharacteristic->addDescriptor(new BLE2902());

    // Create Setpoint Characteristic (with WRITE capability)
    pSetpointCharacteristic = pService->createCharacteristic(
        SETPOINT_CHAR_UUID,
        BLECharacteristic::PROPERTY_READ |
        BLECharacteristic::PROPERTY_WRITE |
        BLECharacteristic::PROPERTY_WRITE_NR |
        BLECharacteristic::PROPERTY_NOTIFY
    );
    pSetpointCharacteristic->addDescriptor(new BLE2902());
    pSetpointCharacteristic->setCallbacks(new SetpointCallbacks());

    // Create Status Characteristic (JSON format)
    pStatusCharacteristic = pService->createCharacteristic(
        STATUS_CHAR_UUID,
        BLECharacteristic::PROPERTY_READ |
        BLECharacteristic::PROPERTY_NOTIFY
    );
    pStatusCharacteristic->addDescriptor(new BLE2902());

    // Start the service
    pService->start();

    // Start advertising
    BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pAdvertising->setScanResponse(true);
    pAdvertising->setMinPreferred(0x06);  // helps with iPhone connections
    pAdvertising->setMinPreferred(0x12);
    BLEDevice::startAdvertising();

    Serial.println("Bluetooth initialized");
    Serial.println("BLE Device name: Heater_Controller");
    Serial.println("Waiting for client connection...");
}

// ========================================
// Update Bluetooth Characteristics
// ========================================
void updateBluetooth() {
    if (!deviceConnected) {
        return;  // No client connected, skip update
    }

    // Update Temperature Characteristic
    char tempStr[16];
    snprintf(tempStr, sizeof(tempStr), "%.1f", currentTemp);
    pTempCharacteristic->setValue(tempStr);
    pTempCharacteristic->notify();

    // Update Setpoint Characteristic
    char setpointStr[16];
    snprintf(setpointStr, sizeof(setpointStr), "%.1f", setpointTemp);
    pSetpointCharacteristic->setValue(setpointStr);
    pSetpointCharacteristic->notify();

    // Update Status Characteristic (JSON format)
    char statusStr[128];
    const char* heaterStatus = heaterOn ? "ON" : "OFF";
    const char* safetyStatus = safetyShutdown ? "SHUTDOWN" : "OK";
    const char* sensorStatus = sensorError ? "ERROR" : "OK";

    snprintf(statusStr, sizeof(statusStr),
             "{\"heater\":\"%s\",\"safety\":\"%s\",\"sensor\":\"%s\"}",
             heaterStatus, safetyStatus, sensorStatus);

    pStatusCharacteristic->setValue(statusStr);
    pStatusCharacteristic->notify();
}

// ========================================
// Read MAX6675 Temperature
// ========================================
float readMAX6675() {
    uint16_t raw = readMAX6675Raw();

    // Check for error (D2 bit set)
    if (raw & 0x04) {
        Serial.println("MAX6675 Error: Thermocouple not connected");
        return SENSOR_ERROR_TEMP;
    }

    // Check for invalid reading
    if (raw == MAX6675_ERROR_VALUE) {
        return SENSOR_ERROR_TEMP;
    }

    // Extract temperature (bits D15-D3, right-shift by 3)
    uint16_t tempValue = raw >> 3;

    // Convert to Celsius (0.25°C per count)
    float tempC = tempValue * 0.25f;

    // Convert to Fahrenheit
    float tempF = (tempC * 9.0f / 5.0f) + 32.0f;

    Serial.printf("Temp: %.2f°F (%.2f°C) [Raw: 0x%04X]\n", tempF, tempC, raw);

    return tempF;
}

// ========================================
// Read MAX6675 Raw Value
// ========================================
uint16_t readMAX6675Raw() {
    uint8_t byte1 = 0, byte2 = 0;

    // Pull CS low to start conversion
    mcp.digitalWrite(MCP_MAX6675_CS, LOW);
    delayMicroseconds(10);

    // Read 16 bits via bit-bang SPI
    bitBangSPI(byte1, byte2);

    // Pull CS high to end conversion
    mcp.digitalWrite(MCP_MAX6675_CS, HIGH);

    // Combine bytes (MSB first)
    uint16_t raw = ((uint16_t)byte1 << 8) | byte2;

    return raw;
}

// ========================================
// Bit-Bang SPI Read
// ========================================
void bitBangSPI(uint8_t& byte1, uint8_t& byte2) {
    byte1 = 0;
    byte2 = 0;

    // Read first byte (bits 15-8)
    for (int i = 7; i >= 0; i--) {
        mcp.digitalWrite(MCP_MAX6675_SCK, HIGH);
        delayMicroseconds(1);

        if (mcp.digitalRead(MCP_MAX6675_SO)) {
            byte1 |= (1 << i);
        }

        mcp.digitalWrite(MCP_MAX6675_SCK, LOW);
        delayMicroseconds(1);
    }

    // Read second byte (bits 7-0)
    for (int i = 7; i >= 0; i--) {
        mcp.digitalWrite(MCP_MAX6675_SCK, HIGH);
        delayMicroseconds(1);

        if (mcp.digitalRead(MCP_MAX6675_SO)) {
            byte2 |= (1 << i);
        }

        mcp.digitalWrite(MCP_MAX6675_SCK, LOW);
        delayMicroseconds(1);
    }
}

// ========================================
// Update Thermostat Logic
// ========================================
void updateThermostat() {
    unsigned long currentMillis = millis();

    // Prevent rapid relay cycling
    if (currentMillis - lastRelayChange < RELAY_MIN_CYCLE_TIME) {
        unsigned long timeRemaining = (RELAY_MIN_CYCLE_TIME - (currentMillis - lastRelayChange)) / 1000;
        Serial.printf("Relay cycling lockout: %lu seconds remaining\n", timeRemaining);
        return;
    }

    // Thermostat logic with hysteresis
    if (!heaterOn) {
        // Turn on if temp falls below (setpoint - hysteresis)
        float turnOnThreshold = setpointTemp - TEMP_HYSTERESIS_F;
        if (currentTemp < turnOnThreshold) {
            setRelay(true);
            lastRelayChange = currentMillis;
            Serial.printf(">>> Heater ON: Temp %.1f°F < Threshold %.1f°F <<<\n",
                         currentTemp, turnOnThreshold);
        } else {
            Serial.printf("Heater OFF: Waiting for temp to drop below %.1f°F (currently %.1f°F)\n",
                         turnOnThreshold, currentTemp);
        }
    } else {
        // Turn off if temp rises above (setpoint + hysteresis)
        float turnOffThreshold = setpointTemp + TEMP_HYSTERESIS_F;
        if (currentTemp > turnOffThreshold) {
            setRelay(false);
            lastRelayChange = currentMillis;
            Serial.printf(">>> Heater OFF: Temp %.1f°F > Threshold %.1f°F <<<\n",
                         currentTemp, turnOffThreshold);
        } else {
            Serial.printf("Heater ON: Waiting for temp to rise above %.1f°F (currently %.1f°F)\n",
                         turnOffThreshold, currentTemp);
        }
    }
}

// ========================================
// Update Display
// ========================================
void updateDisplay() {
    // Temperature display (moved down from y=50 to y=100)
    tft.fillRect(0, 75, 480, 60, COLOR_BG);
    tft.setTextColor(sensorError ? COLOR_TEMP_HIGH : COLOR_TEMP_NORMAL, COLOR_BG);
    tft.setTextSize(3);
    tft.setTextDatum(MC_DATUM);

    if (sensorError) {
        tft.drawString("ERROR", 240, 100);
    } else {
        snprintf(displayBuffer, sizeof(displayBuffer), "%.1f F", currentTemp);
        tft.drawString(displayBuffer, 240, 100);
    }

    // Setpoint display (moved down from y=110 to y=145)
    tft.fillRect(0, 130, 480, 40, COLOR_BG);
    tft.setTextColor(COLOR_SETPOINT, COLOR_BG);
    tft.setTextSize(2);
    snprintf(displayBuffer, sizeof(displayBuffer), "Set: %.1f F", setpointTemp);
    tft.drawString(displayBuffer, 240, 145);

    // Heater status (moved down from y=145 to y=180)
    tft.fillRect(0, 165, 480, 30, COLOR_BG);
    tft.setTextColor(heaterOn ? COLOR_HEATER_ON : COLOR_HEATER_OFF, COLOR_BG);
    tft.setTextSize(2);

    if (safetyShutdown) {
        tft.setTextColor(COLOR_TEMP_HIGH, COLOR_BG);
        tft.drawString("SAFETY SHUTDOWN!", 240, 180);
    } else {
        tft.drawString(heaterOn ? "HEATER ON" : "HEATER OFF", 240, 180);
    }

    // Draw buttons (static, only need to draw once)
    static bool buttonsDrawn = false;
    if (!buttonsDrawn) {
        drawButton(BUTTON_UP_X, BUTTON_UP_Y, BUTTON_WIDTH, BUTTON_HEIGHT, "UP", COLOR_BUTTON);
        drawButton(BUTTON_DOWN_X, BUTTON_DOWN_Y, BUTTON_WIDTH, BUTTON_HEIGHT, "DOWN", COLOR_BUTTON);
        buttonsDrawn = true;
    }
}

// ========================================
// Draw Initial UI
// ========================================
void drawUI() {
    tft.fillScreen(COLOR_BG);

    // Title - split into two lines with color accent
    tft.setTextDatum(MC_DATUM);
    tft.setTextSize(3);

    // Top line with yellow accent
    tft.setTextColor(TFT_YELLOW, COLOR_BG);
    tft.drawString("CREWCHIEFSTEVE", 240, 15);

    // Bottom line same size
    tft.setTextColor(TFT_WHITE, COLOR_BG);
    tft.drawString("TECHNOLOGIES", 240, 40);

    // Decorative line under title
    tft.drawFastHLine(40, 65, 400, TFT_YELLOW);

    // Draw buttons
    drawButton(BUTTON_UP_X, BUTTON_UP_Y, BUTTON_WIDTH, BUTTON_HEIGHT, "UP", COLOR_BUTTON);
    drawButton(BUTTON_DOWN_X, BUTTON_DOWN_Y, BUTTON_WIDTH, BUTTON_HEIGHT, "DOWN", COLOR_BUTTON);

    updateDisplay();
}

// ========================================
// Draw Button
// ========================================
void drawButton(int x, int y, int w, int h, const char* label, uint16_t color) {
    tft.fillRoundRect(x, y, w, h, 8, color);
    tft.drawRoundRect(x, y, w, h, 8, TFT_WHITE);

    tft.setTextDatum(MC_DATUM);
    tft.setTextColor(COLOR_BUTTON_TEXT, color);
    tft.setTextSize(2);
    tft.drawString(label, x + w/2, y + h/2);
}

// ========================================
// Handle Touch Input
// ========================================
void handleTouch() {
    uint16_t touchX = 0, touchY = 0;

    // Check if screen is being touched (TFT_eSPI built-in touch)
    bool touched = tft.getTouch(&touchX, &touchY, 300);  // 300 = pressure threshold

    // If not touched, return
    if (!touched) {
        return;
    }

    unsigned long currentMillis = millis();

    // Debounce
    if (currentMillis - lastTouchTime < TOUCH_DEBOUNCE_MS) {
        return;
    }

    // Show touch detected on screen (top right corner)
    tft.fillRect(400, 0, 80, 20, TFT_GREEN);
    tft.setTextColor(TFT_BLACK, TFT_GREEN);
    tft.setTextSize(1);
    tft.setTextDatum(MC_DATUM);
    tft.drawString("TOUCH!", 440, 10);

    // Check if UP button pressed
    if (touchX >= BUTTON_UP_X && touchX <= (BUTTON_UP_X + BUTTON_WIDTH) &&
        touchY >= BUTTON_UP_Y && touchY <= (BUTTON_UP_Y + BUTTON_HEIGHT)) {

        if (setpointTemp < MAX_SETPOINT_F) {
            setpointTemp += SETPOINT_INCREMENT;
            Serial.printf("UP button pressed! Setpoint increased to %.1f°F\n", setpointTemp);

            // Flash button green to show response
            drawButton(BUTTON_UP_X, BUTTON_UP_Y, BUTTON_WIDTH, BUTTON_HEIGHT, "UP", TFT_GREEN);
            delay(100);
            drawButton(BUTTON_UP_X, BUTTON_UP_Y, BUTTON_WIDTH, BUTTON_HEIGHT, "UP", COLOR_BUTTON);

            // Force immediate display update
            updateDisplay();

            // Reset safety shutdown if user adjusts setpoint (allows restart)
            if (safetyShutdown && currentTemp < SAFETY_MAX_TEMP_F && !sensorError) {
                safetyShutdown = false;
                Serial.println("Safety shutdown reset");
            }
        }

        lastTouchTime = currentMillis;
    }

    // Check if DOWN button pressed
    else if (touchX >= BUTTON_DOWN_X && touchX <= (BUTTON_DOWN_X + BUTTON_WIDTH) &&
             touchY >= BUTTON_DOWN_Y && touchY <= (BUTTON_DOWN_Y + BUTTON_HEIGHT)) {

        if (setpointTemp > MIN_SETPOINT_F) {
            setpointTemp -= SETPOINT_INCREMENT;
            Serial.printf("DOWN button pressed! Setpoint decreased to %.1f°F\n", setpointTemp);

            // Flash button green to show response
            drawButton(BUTTON_DOWN_X, BUTTON_DOWN_Y, BUTTON_WIDTH, BUTTON_HEIGHT, "DOWN", TFT_GREEN);
            delay(100);
            drawButton(BUTTON_DOWN_X, BUTTON_DOWN_Y, BUTTON_WIDTH, BUTTON_HEIGHT, "DOWN", COLOR_BUTTON);

            // Force immediate display update
            updateDisplay();

            // Reset safety shutdown if user adjusts setpoint (allows restart)
            if (safetyShutdown && currentTemp < SAFETY_MAX_TEMP_F && !sensorError) {
                safetyShutdown = false;
                Serial.println("Safety shutdown reset");
            }
        }

        lastTouchTime = currentMillis;
    }

    // Clear the touch indicator after a short delay
    delay(150);
    tft.fillRect(400, 0, 80, 20, COLOR_BG);
}

// ========================================
// Set Relay State
// ========================================
void setRelay(bool state) {
    heaterOn = state;
    // Relay is active HIGH (ON=HIGH, OFF=LOW)
    mcp.digitalWrite(MCP_RELAY_PIN, state ? HIGH : LOW);
    Serial.printf("Relay set to %s\n", state ? "ON" : "OFF");
}
